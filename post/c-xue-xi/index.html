<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>C# 学习 | 长胖是个梦想</title>
<link rel="shortcut icon" href="https://zhoujun2303.github.io/favicon.ico?v=1695871631810">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://zhoujun2303.github.io/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="C# 学习 | 长胖是个梦想 - Atom Feed" href="https://zhoujun2303.github.io/atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">


<script async src="https://www.googletagmanager.com/gtag/js?id=UA-241589831-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-241589831-1');
</script>


    <meta name="description" content="
修饰符

public 
公共的

private
私有，类内部才能访问

protected
只修饰成员，类内部及子类内部可以访问

static 
修饰类为静态类，不能实例化类
static修饰构造函数时，构造函数不能含有任何参数及修..." />
    <meta name="keywords" content="C#" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.5.1/build/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://zhoujun2303.github.io">
  <img class="avatar" src="https://zhoujun2303.github.io/images/avatar.png?v=1695871631810" alt="">
  </a>
  <h1 class="site-title">
    长胖是个梦想
  </h1>
  <p class="site-description">
    10000小时定律
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="https://zhoujun2303.github.io/post/keyword" class="menu">
          Key words
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
        <a href="https://github.com/ZhouJun2303" target="_blank">
          <i class="ri-github-line"></i>
        </a>
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              C# 学习
            </h2>
            <div class="post-info">
              <span>
                2021-04-10 13:51 PM
              </span>
              <span>
                3 min read
              </span>
              
                <a href="https://zhoujun2303.github.io/tag/cPp_1OaTH/" class="post-tag">
                  # C#
                </a>
              
            </div>
            
            <div class="post-content-wrapper">
              <div class="post-content" v-pre>
                <ul>
<li>修饰符</li>
</ul>
<pre><code>public 
公共的

private
私有，类内部才能访问

protected
只修饰成员，类内部及子类内部可以访问

static 
修饰类为静态类，不能实例化类
static修饰构造函数时，构造函数不能含有任何参数及修饰符
构造函数：名字和类名相同（实例，静态，私有）

internal
默认修饰符，同一个程序集内成员可以访问

abstract
abstract可以修饰类，方法，属性
抽象类不能被实例化
抽象不能用sealed修饰，sealed修饰不能被继承
抽象方法只能定义在抽象类，抽象方法只声明，不提供实现
抽象方法声明不能用virtual或者static修饰
不能在静态属性上用abstract修饰
抽象属性在非抽象派生类覆盖重写，须使用override修饰符

partial
只能修饰类，可以将一个分成部分写在不同文件，这些文件只能在同一个程序集

sealed
修饰类不能被继承，修饰方法不能被重写

virtual
修饰方法，父类可以有该方法的实现，子类可以重写改方法(注意和abstract区别)

override
表示该方法覆盖了父类的方法

readonly
修饰字段，运行时只读，修改无需编译

const
只读，编译前确定值

operator
在类或结构声明中声明运算符

base
调用构造函数，或者基类被重写的方法
</code></pre>
<ul>
<li>注释</li>
</ul>
<pre><code>// 不会被编译
/// 会被编译（影响编译速度，不影响执行速度）在调用代码时调用感知
/// &lt;summary&gt;
///
/// &lt;/summary&gt;
</code></pre>
<ul>
<li>协程</li>
</ul>
<pre><code>https://blog.csdn.net/qq_36684665/article/details/80829049
https://www.bilibili.com/video/BV1f5411G7bp?p=14

StartCoroutine(&quot;BezierToTargetPosIenum&quot;,0.1f);//way1 
StartCoroutine(BezierToTargetPosIenum(0.1f));//way2
 /// &lt;summary&gt;
/// 协程测试
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;dt&quot;&gt;&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        IEnumerator   BezierToTargetPosIenum(float dt)
        {
            Debug.Log(&quot;协程测试 开始&quot;);
            while (Count&lt;10)
            {
                Count++;
                yield return null;
            }
            Debug.Log(&quot;计数 结束&quot;);
            yield return new WaitForSeconds(0.5f);
            Debug.Log(&quot;协程测试 结束&quot;);
        }
</code></pre>
<ul>
<li>委托</li>
</ul>
<pre><code> //委托
        delegate int  Multidelegate(int a,int b);
        Multidelegate myMultidelegate;

        public void TestMultidelegate()
        {
            myMultidelegate = AddNumber;
            myMultidelegate += AddNumber;
            myMultidelegate -= AddNumber;
            // 没有进行任何操作是 为null
            if (myMultidelegate == null) return;
          Debug.Log(  myMultidelegate(3, 5));
        }
</code></pre>
<ul>
<li>接口</li>
</ul>
<pre><code> //接口
    public interface TestInterFace1
    {
        void Test1();
    }

    public interface TestInterFace2&lt;T&gt;
    {
        void Test2(T s);
    }

//使用接口
 public partial class GameEntry : MonoBehaviour,TestInterFace1,TestInterFace2&lt;int&gt;
 
  //接口实现
        public void Test1()
        {
            Debug.Log(&quot;Test1&quot;);
        }

        public void Test2(int num)
        {
            Debug.Log(&quot;Test2&quot;+num);
        }
</code></pre>
<ul>
<li>泛型</li>
</ul>
<pre><code>//泛型 
        public List&lt;string&gt; StrList = new List&lt;string&gt;();

        //class struct new  mono
        public T GenericTest&lt;T, U, V&gt;(T t, U u, V v) where T :class
        {
            return t;
        }

        public void GenericTestS()
        {
            var test1 = GenericTest&lt;TestSerializable, int, float&gt;(new TestSerializable(), 10, 10f);
            var tets2 = GenericTest(new TestSerializable(), 10, 10f);
        }
</code></pre>

              </div>
              <div class="toc-container">
                
              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://zhoujun2303.github.io/post/hei-ping-guo/">
              <h3 class="post-title">
                黑苹果
              </h3>
            </a>
          </div>
        

        
          
            <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

<div id="gitalk-container"></div>

<script>

  var gitalk = new Gitalk({
    clientID: 'ca79a66585e72af3bff6',
    clientSecret: '4cf7eeea526df4a9d2fa6bfb14fcb3f135652731',
    repo: 'zhoujun2303.github.io',
    owner: 'zhoujun2303',
    admin: ['zhoujun2303'],
    id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
    distractionFreeMode: false  // Facebook-like distraction free mode
  })

  gitalk.render('gitalk-container')

</script>

          

          
        

        <div class="site-footer">
  Powered by <a href="https://github.com/ZhouJun2303/">胖胖</a>
  <a class="rss" href="https://zhoujun2303.github.io/atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
